\documentclass{article}
\usepackage[portrait, headheight = 0cm, margin=0.25cm, top = 0.25cm]{geometry} 
\usepackage{graphicx}
\usepackage[dvipsnames,table]{xcolor}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage[export]{adjustbox}
\usepackage{hyperref}
\usepackage{array}
\usepackage{enumitem}
\usepackage{fontspec}
\usepackage{tcolorbox}
\tcbuselibrary{skins, breakable}

\title{
\vskip 10cm
{\bf\huge Rasterizer}
\vskip 1cm
{\bf\huge images from complex vectors}
\vskip 3cm
}
\author{Wigerich}

\begin{document}
\maketitle

\newpage
\tableofcontents

\newpage
\section{Rasterizer Overview}

The \texttt{raster.py} module turns a cloud of points (typically complex
numbers in the plane) into high-quality, bilevel (0/255) PNG images.  It is
organised around three main stages:

\begin{enumerate}
  \item \emph{Dot stamping}: generate small circular ``stamps'' and apply them
        at many point locations, in a Numba-accelerated loop.
  \item \emph{Radius bucketing}: group points by dot radius so that stamps can
        be reused efficiently.
  \item \emph{Projection and output}: map complex points to pixel
        coordinates, convert the canvas to a \texttt{pyvips} image, optionally
        add labels and a passepartout, and write a 1-bit PNG (or a mosaic).
\end{enumerate}

Conceptually, you start with a complex vector $z$, project it onto a
square canvas, choose a dot radius for each point, group the points by
radius, stamp discs for each group, and then hand the resulting NumPy
array to \texttt{pyvips} for final rendering and saving.

\newpage
\section{Dot Stamping}

Dot stamping converts each point into a filled disc on a 2-D canvas.
A disc is represented by two integer offset arrays \texttt{(dy, dx)}. These
describe all pixel positions inside the radius-\(r\) circle centred at each point.

\subsection{Disc Stamp Construction}

For a given radius \( r \), we want all pixels strictly inside the disc:
\[
(x - x_0)^2 + (y - y_0)^2 < r^2.
\]

This is implemented by constructing a small grid and masking out the
interior of the circle:

\begin{tcolorbox}[breakable, enhanced, colback=black!2, colframe=black!50]
\begin{verbatim}
def make_disc_offsets(r: int):
    r = int(max(1, r))
    yy, xx = np.mgrid[-r:r+1, -r:r+1]
    mask = (xx*xx + yy*yy) < r*r
    return yy[mask].astype(np.int32), xx[mask].astype(np.int32)
\end{verbatim}
\end{tcolorbox}

Explanation:

\begin{itemize}
  \item \verb|np.mgrid[-r:r+1, -r:r+1]| builds a square grid of integer
        coordinates centred at $(0,0)$, covering $(2r+1)\times(2r+1)$ pixels.
  \item The boolean mask \verb|(xx*xx + yy*yy) < r*r| selects pixels whose
        squared distance from the origin is strictly less than \(r^2\).
  \item The \verb|yy[mask]| and \verb|xx[mask]| arrays are flattened and
        cast to \verb|int32|, giving:
        \begin{itemize}
          \item \verb|dy|: vertical offsets (row offsets),
          \item \verb|dx|: horizontal offsets (column offsets).
        \end{itemize}
\end{itemize}

Given a centre pixel $(y_0, x_0)$, the disc pixels are
\[
(y_0 + \Delta y[i],\ x_0 + \Delta x[i]) \quad i = 0,\dots,k-1.
\]

To avoid recomputing these offsets for every point, the code builds a
cache of all radii that will actually be used:

\begin{tcolorbox}[breakable, enhanced, colback=black!2, colframe=black!50]
\begin{verbatim}
def build_disc_offset_cache_from_rpx(r_px, rmin):
    """
    Build a cache {radius -> (dy, dx)} for all radii that will be stamped.
    Uses absolute radii and ignores those < rmin.
    """
    if r_px.size == 0:
        return {}
    r_abs = np.abs(r_px).astype(np.int32, copy=False)
    m = r_abs >= rmin
    if not np.any(m):
        return {}
    radii = np.unique(r_abs[m])
    return {int(r): make_disc_offsets(int(r)) for r in radii}
\end{verbatim}
\end{tcolorbox}

Only radii $\ge r_{\min}$ are kept, and each unique radius has one
precomputed stencil \verb|(dy, dx)|. At render time, you look up the
stencil corresponding to each radius bucket.

\subsection{Stamping Kernel}

The Numba-accelerated kernel \verb|stamp_points| applies a fixed
\verb|(dy, dx)| stencil to many point centres on the canvas:

\begin{tcolorbox}[breakable, enhanced, colback=black!2, colframe=black!50]
\begin{verbatim}
@njit(cache=True, nogil=True, parallel=True, fastmath=True)
def stamp_points(canvas, ys, xs, dy, dx, value: np.int8 = 255):
    """
    Args:
        canvas: np.zeros((H, W), np.uint8) - pixels are stamped here
        ys: int32 array - y pixel coordinates
        xs: int32 array - x pixel coordinates
        dy: int32 array - stamp offsets in y
        dx: int32 array - stamp offsets in x
        value: np.int8 - value to stamp (default 255)
    """
    H, W = canvas.shape
    n = ys.size; k = dy.size
    for i in prange(n):
        y0 = ys[i]; x0 = xs[i]
        for j in range(k):
            y = y0 + dy[j]; x = x0 + dx[j]
            if 0 <= y < H and 0 <= x < W:
                canvas[y, x] = value  # 255 draw, 0 erase
\end{verbatim}
\end{tcolorbox}

Key points:

\begin{itemize}
  \item \verb|canvas| is a 2D \verb|uint8| array of shape $(H, W)$.
  \item \verb|ys| and \verb|xs| are integer pixel coordinates for the disc
        centres.
  \item \verb|dy| and \verb|dx| are the offsets returned by
        \verb|make_disc_offsets|.
  \item The outer loop (over points) is parallelised using \verb|prange|, so
        each thread stamps its subset of points.
  \item For each centre $(y_0, x_0)$ and each offset $(\Delta y, \Delta x)$
        the kernel computes the target $(y, x)$ and, if it lies inside the
        canvas, assigns \verb|value|.
\end{itemize}

In practice, you call \verb|stamp_points| once per radius bucket: all points
in the same bucket share the same stencil \verb|(dy, dx)|.

\newpage
\section{Radius Bucketing}

Radius bucketing groups points by dot radius so that each radius is stamped
in a single batch. This is faster than stamping each point individually with
its own stencil.

Given one radius per point (in pixels), we want to:

\begin{itemize}
  \item discard radii outside $[r_{\min}, r_{\max}]$,
  \item group remaining points by radius,
  \item prepare indexing arrays so each radius group can be processed in one
        tight loop.
\end{itemize}

\subsection{Serial Bucketing}

The serial implementation \verb|bucket_by_radius| builds a full histogram
over \verb|[r_min, r_max]| and then compacts it:

\begin{tcolorbox}[breakable, enhanced, colback=black!2, colframe=black!50]
\begin{verbatim}
@njit(cache=True, nogil=True)
def bucket_by_radius(r_px: np.ndarray, r_min: int, r_max: int):
    n = r_px.size
    if n == 0 or r_min > r_max:
        return (np.empty(0, np.int64),
                np.empty(0, np.int32),
                np.empty(0, np.int64),
                np.empty(0, np.int64))
    size = r_max + 1
    counts_full = np.zeros(size, np.int64)
    kept = 0
    for i in range(n):
        r = r_px[i]
        if r_min <= r <= r_max:
            counts_full[r] += 1; kept += 1

    if kept == 0:
        return (np.empty(0, np.int64),
                np.empty(0, np.int32),
                np.empty(0, np.int64),
                np.empty(0, np.int64))

    # exclusive prefix
    starts_full = np.zeros(size, np.int64)
    s = 0
    for r in range(r_min, r_max + 1):
        c = counts_full[r]; starts_full[r] = s; s += c

    # stable scatter into 'order'
    order = np.empty(kept, np.int64)
    write_ptr = starts_full.copy()
    for i in range(n):
        r = r_px[i]
        if r_min <= r <= r_max:
            p = write_ptr[r]; order[p] = i; write_ptr[r] = p + 1

    # compact radii into (r_vals, starts, counts)
    k = 0
    for r in range(r_min, r_max + 1):
        if counts_full[r] > 0: k += 1
    r_vals  = np.empty(k, np.int32)
    starts  = np.empty(k, np.int64)
    counts  = np.empty(k, np.int64)
    pos = 0
    for r in range(r_min, r_max + 1):
        c = counts_full[r]
        if c > 0:
            r_vals[pos] = np.int32(r)
            starts[pos] = starts_full[r]
            counts[pos] = c
            pos += 1
    return order, r_vals, starts, counts
\end{verbatim}
\end{tcolorbox}

Returned arrays:

\begin{itemize}
  \item \verb|order|: indices into the original radius array, grouped by
        radius.
  \item \verb|r_vals|: the unique radii that actually appear, sorted ascending.
  \item \verb|starts|: for each \verb|r_vals[i]|, the starting offset in
        \verb|order|.
  \item \verb|counts|: for each \verb|r_vals[i]|, how many indices belong to
        that radius.
\end{itemize}

To process all points with radius \verb|r_vals[i]|:

\begin{tcolorbox}[enhanced, colback=black!2, colframe=black!50]
\begin{verbatim}
idx = order[starts[i] : starts[i] + counts[i]]
\end{verbatim}
\end{tcolorbox}

You use \verb|idx| to index into your coordinate arrays and stamp them with
the stencil corresponding to \verb|r_vals[i]|.

\subsection{Parallel Bucketing}

\verb|bucket_by_radius_parallel| implements the same interface but uses
block-wise histograms and parallel scatter to scale to large arrays:

\begin{tcolorbox}[breakable, enhanced, colback=black!2, colframe=black!50]
\begin{verbatim}
@njit(cache=True, nogil=True, parallel=True)
def bucket_by_radius_parallel(r_px: np.ndarray, r_min: int, r_max: int):
    n = r_px.size
    if n == 0 or r_min > r_max:
        return (np.empty(0, np.int64),
                np.empty(0, np.int32),
                np.empty(0, np.int64),
                np.empty(0, np.int64))

    R = r_max - r_min + 1
    if R <= 0:
        return (np.empty(0, np.int64),
                np.empty(0, np.int32),
                np.empty(0, np.int64),
                np.empty(0, np.int64))

    # choose #blocks; ~64k elems per block, cap 1024
    B = (n + 65535) // 65536
    if B < 1: B = 1
    if B > 1024: B = 1024

    local = np.zeros((B, R), np.int64)

    # per-block histograms
    for b in prange(B):
        lo = (n * b) // B
        hi = (n * (b + 1)) // B
        row = local[b]
        for i in range(lo, hi):
            r = r_px[i]
            if r_min <= r <= r_max:
                row[r - r_min] += 1

    # reduce to global counts
    counts = np.zeros(R, np.int64)
    for r in range(R):
        s = 0
        for b in range(B):
            s += local[b, r]
        counts[r] = s

    kept = 0
    for r in range(R):
        kept += counts[r]
    if kept == 0:
        return (np.empty(0, np.int64),
                np.empty(0, np.int32),
                np.empty(0, np.int64),
                np.empty(0, np.int64))

    # global exclusive starts
    starts_full = np.empty(R, np.int64)
    s = 0
    for r in range(R):
        starts_full[r] = s
        s += counts[r]

    # per-block starts per radius
    block_starts = np.empty((B, R), np.int64)
    for r in range(R):
        off = starts_full[r]
        for b in range(B):
            block_starts[b, r] = off
            off += local[b, r]

    # parallel stable scatter: each block writes its own slice
    order = np.empty(kept, np.int64)
    for b in prange(B):
        lo = (n * b) // B
        hi = (n * (b + 1)) // B
        wp = block_starts[b].copy()
        for i in range(lo, hi):
            r = r_px[i]
            if r_min <= r <= r_max:
                rr = r - r_min
                p = wp[rr]
                order[p] = i
                wp[rr] = p + 1

    # compact to (r_vals, starts, counts) in ascending radius
    k = 0
    for r in range(R):
        if counts[r] > 0:
            k += 1

    r_vals = np.empty(k, np.int32)
    starts = np.empty(k, np.int64)
    cnts   = np.empty(k, np.int64)

    pos = 0
    for r in range(R):
        c = counts[r]
        if c > 0:
            r_vals[pos] = np.int32(r_min + r)
            starts[pos] = starts_full[r]
            cnts[pos]   = c
            pos += 1

    return order, r_vals, starts, cnts
\end{verbatim}
\end{tcolorbox}

The semantics of \verb|order|, \verb|r_vals|, \verb|starts| and
\verb|cnts| (counts) are identical to the serial version. The only
difference is that the histogram and scatter phases are block-parallel and
avoid atomics by precomputing disjoint write ranges.

\newpage
\section{Projection and Canvas}

Once you know where the dots live in the complex plane, you need to map
them to integer pixel coordinates in a square canvas.

\subsection{Projection to Canvas}

The function \verb|project_to_canvas| maps complex numbers to integer
pixel coordinates in a square image of size \verb|pix|:

\begin{tcolorbox}[breakable, enhanced, colback=black!2, colframe=black!50]
\begin{verbatim}
def project_to_canvas(z: np.ndarray, pix: int, margin_frac: float):
    if z.size < 1:
        return np.empty(0, dtype=np.int32), np.empty(0, dtype=np.int32)
    half = (0.5 * max(np.ptp(z.real), np.ptp(z.imag))) * (1.0 + 2.0 * margin_frac)
    span  = 2.0 * half
    if span < 1e-10:
        span = 1
    px_per = (int(pix) - 1) / span
    px = np.rint((z.real + half) * px_per).astype(np.int32)
    py = np.rint((half - z.imag) * px_per).astype(np.int32)
    px = np.clip(px, 0, int(pix) - 1)
    py = np.clip(py, 0, int(pix) - 1)
    return px, py
\end{verbatim}
\end{tcolorbox}

Explanation:

\begin{itemize}
  \item \verb|np.ptp(z.real)| and \verb|np.ptp(z.imag)| are the real and
        imaginary ranges of the point cloud.
  \item \verb|half| is half of the larger range, scaled by
        \verb|(1 + 2 * margin_frac)| to leave space around the points.
  \item The complex plane is mapped to a square window
        $[-\texttt{half}, +\texttt{half}] \times [-\texttt{half}, +\texttt{half}]$.
  \item \verb|px_per| is the number of pixels per unit; using
        \verb|(pix - 1)| ensures the mapping spans $[0, \texttt{pix}-1]$.
  \item The vertical coordinate is flipped: imaginary up is image down.
  \item Clipping guarantees all indices are valid.
\end{itemize}

For a simple point image (without disc stamping) you can render directly:

\begin{tcolorbox}[enhanced, colback=black!2, colframe=black!50]
\begin{verbatim}
def render_to_canvas(z: np.ndarray, pix: int, margin_frac: float):
    canvas = np.zeros((int(pix), int(pix)), np.uint8)
    px, py = project_to_canvas(z, pix, margin_frac)
    canvas[px, py] = 255
    return canvas
\end{verbatim}
\end{tcolorbox}

\newpage
\section{NumPy \texorpdfstring{$\rightarrow$}{->} VIPS Bridge}

\subsection{Wrapping NumPy as a VIPS Image}

The function \verb|np_to_vips_gray_u8| consumes a 2D NumPy array and returns
a single-band \verb|pyvips| image:

\begin{tcolorbox}[enhanced, colback=black!2, colframe=black!50]
\begin{verbatim}
def np_to_vips_gray_u8(arr: np.ndarray) -> vips.Image:
    if arr.dtype != np.uint8:
        arr = arr.astype(np.uint8, copy=False)
    H, W = arr.shape
    return vips.Image.new_from_memory(arr.data, W, H, 1, "uchar")
\end{verbatim}
\end{tcolorbox}

Points:

\begin{itemize}
  \item Ensures \verb|uint8| pixels (\verb|"uchar"| in VIPS).
  \item Uses the underlying buffer of \verb|arr| without copying.
  \item Treats the data as a 1-band grayscale image of size \verb|W x H|.
\end{itemize}

This is the bridge used by all later functions that operate on VIPS images.

\newpage
\section{Footer Labels}

\subsection{Dynamic Footer Rendering}

\verb|add_footer_label| draws a text label along the bottom of the image.
Font size is chosen automatically based on the image height and constrained
to fit a given width:

\begin{tcolorbox}[breakable, enhanced, colback=black!2, colframe=black!50]
\begin{verbatim}
def add_footer_label(
    base: vips.Image,
    text: str,
    *,
    footer_frac: float = 0.02,   # ~ target glyph height vs H
    pad_lr_px: int = 40,
    dpi: int = 300,
    align: str = "centre",
    invert: bool = False,
    font_family: str = "Courier New",
    font_weight: str = "Bold",
    min_px: int = 10,
    max_px_frac: float = 0.05,
    max_retries: int = 8,
) -> vips.Image:
    ...
\end{verbatim}
\end{tcolorbox}

Core behaviour:

\begin{enumerate}
  \item Compute a target glyph height as a fraction of the image height
        (\verb|footer_frac|) and convert that to a point size at the given
        \verb|dpi|.
  \item Split \verb|text| on commas, trim whitespace, and drop empty tokens.
        These tokens are then packed into lines such that each line fits into
        the effective width \verb|box_w = W - 2 * pad_lr_px|.
  \item For a candidate font string
        \verb|"font_family font_weight pt"|, call \verb|vips.Image.text|
        to test the rendered size. If too large (exceeds width or
        \verb|max_px_frac * H|), shrink the point size and retry.
  \item Once an acceptable glyph image is found, convert it to a 0/255 mask
        using \verb|(glyph > 0).ifthenelse(255, 0)|.
  \item Insert this glyph into a full-size mask at the appropriate bottom
        position, then composite with \verb|base|:
        \begin{itemize}
          \item \verb|invert=False|: OR-like composition so text is drawn
                on top in the current polarity.
          \item \verb|invert=True|: combine with an inverted mask so text
                appears as a ``cut-out'' when the image is inverted.
        \end{itemize}
\end{enumerate}

If a valid font size cannot be found within \verb|max_retries| attempts,
the function returns the original image unchanged.

\newpage
\section{Rounded Passepartout}

\subsection{Automatic Mat and Rounded Window}

\verb|add_rounded_passepartout_bilevel_pct| wraps a square image in a
bilevel passepartout (mat) with optional rounded inner corners:

\begin{tcolorbox}[breakable, enhanced, colback=black!2, colframe=black!50]
\begin{verbatim}
def add_rounded_passepartout_bilevel_pct(
    img: vips.Image,
    margin_frac: float = 0.10,   # 10% of width
    radius_frac: float = 0.04,   # 4% of width
    auto_white_bg: bool = True,
    mat_value: int | None = None,
):
    ...
\end{verbatim}
\end{tcolorbox}

Process:

\begin{itemize}
  \item Enforce that \verb|img| is single-band and cast to \verb|"uchar"|.
  \item Compute \verb|margin_px| and \verb|radius_px| as fractions of the
        image width.
  \item Decide mat colour (black or white):
        \begin{itemize}
          \item If \verb|auto_white_bg=True|, sample thin strips along the
                image border, join them, and compute the average brightness.
                If the mean is dark, choose a white mat (255), otherwise
                choose a black mat (0).
          \item If \verb|auto_white_bg=False|, derive the mat value from
                \verb|mat_value| (defaulting to white if not provided).
        \end{itemize}
  \item Create a new larger canvas filled with the mat colour and insert
        the original image in the centre.
\end{itemize}

If \verb|radius_px <= 0|, the function simply returns a thresholded
(bilevel) version of this mat+image composite. Otherwise:

\begin{enumerate}
  \item Clamp \verb|radius_px| so it does not exceed half the width or
        height of the inner window.
  \item Build a mask image where the inner rounded rectangle region has
        value 255 and the mat outside has value 0, using:
        \begin{itemize}
          \item One horizontal and one vertical filled rectangle for the
                straight sections.
          \item Four filled circles at the inner window corners for the
                rounded corners.
        \end{itemize}
  \item Use \verb|mask.ifthenelse| to select the pasted image inside the
        rounded rectangle and the mat outside.
  \item Apply a final threshold to ensure the result is strictly 0/255.
\end{enumerate}

The result is a square, bilevel image with a clean rounded window around
the content, centred within a solid mat.

\newpage
\section{Saving PNGs and Mosaics}

\subsection{Saving a Single Bilevel PNG}

\verb|save_png_bilevel| is the main entry point for writing a single 1-bit
PNG from a NumPy canvas:

\begin{tcolorbox}[breakable, enhanced, colback=black!2, colframe=black!50]
\begin{verbatim}
def save_png_bilevel(
    canvas: np.ndarray,
    out_path: str,
    invert: bool,
    footer_text: str | None = None,
    *,
    footer_pad_lr_px: int = 48,
    footer_dpi: int = 300,
    passepartout = False
):
    """
    Save a bilevel (0/255) PNG from a numpy array, optionally adding a footer
    title and/or a rounded passepartout.
    """
    if canvas.dtype != np.uint8:
        canvas = canvas.astype(np.uint8, copy=False)
    if invert:
        canvas = 255 - canvas

    H, W = canvas.shape
    base = vips.Image.new_from_memory(canvas.data, W, H, 1, "uchar")

    if footer_text:
        base = add_footer_label(
            base,
            footer_text,
            pad_lr_px=footer_pad_lr_px,
            dpi=footer_dpi,
            align="centre",
            invert=invert,
        )

    if passepartout:
        base = add_rounded_passepartout_bilevel_pct(
            base,
            margin_frac = 0.01,
            radius_frac = 0.10,
            auto_white_bg = True,
            mat_value = None,
        )

    base.write_to_file(
        out_path,
        compression=1,
        effort=1,
        filter="none",
        interlace=False,
        strip=True,
        bitdepth=1,
    )
\end{verbatim}
\end{tcolorbox}

Notable details:

\begin{itemize}
  \item The image is always written as a 1-bit PNG (\verb|bitdepth=1|).
  \item Compression is deliberately mild and filtering disabled for speed.
  \item Footer labels are drawn in the correct polarity (respecting
        \verb|invert|).
  \item Passepartout wrapping is entirely optional and can be toggled per
        call.
\end{itemize}

\subsection{Mosaic Composition}

\verb|save_mosaic_png_bilevel| composes several tiles into a single
mosaic image and saves it as a 1-bit PNG:

\begin{tcolorbox}[breakable, enhanced, colback=black!2, colframe=black!50]
\begin{verbatim}
def save_mosaic_png_bilevel(
    tiles: list[np.ndarray],
    titles: list[str] | None,
    *,
    cols: int,
    gap: int,
    out_path: str,
    invert: bool,
    footer_pad_lr_px: int = 48,
    footer_dpi: int = 300,
    thumbnail: int = None
) -> None:
    """
    Compose a mosaic from numpy tiles (uint8, 0/255). If 'titles' is provided,
    draw a footer on *each* tile before compositing. Saves as 1-bit PNG.
    """
    if not tiles:
        raise ValueError("No tiles provided")

    # Normalize titles
    if titles is None:
        titles = [None] * len(tiles)
    elif len(titles) == 1 and len(tiles) > 1:
        titles = titles * len(tiles)
    elif len(titles) != len(tiles):
        raise ValueError("Length of 'titles' must be 1 or match number of tiles")

    # First tile defines base size
    t0 = np_to_vips_gray_u8(tiles[0])
    tile_h, tile_w = t0.height, t0.width

    vtiles: list[vips.Image] = []
    for arr, title in zip(tiles, titles):
        vt = np_to_vips_gray_u8(arr)
        # pad to match first tile size if needed
        if vt.width != tile_w or vt.height != tile_h:
            tw = max(tile_w, vt.width)
            th = max(tile_h, vt.height)
            vt = pad_to_square(vt, max(tw, th))
            tile_w = vt.width
            tile_h = vt.height
        # add footer per-tile, before global invert
        if title:
            vt = add_footer_label(
                vt,
                title,
                pad_lr_px=footer_pad_lr_px,
                dpi=footer_dpi,
                align="centre",
                invert=False,
            )
        vtiles.append(vt)

    n = len(vtiles)
    rows = math.ceil(n / cols)
    W = cols * tile_w + (cols - 1) * gap
    H = rows * tile_h + (rows - 1) * gap
    base = vips.Image.black(W, H)

    # place tiles row-major
    for i, vt in enumerate(vtiles):
        r, c = divmod(i, cols)
        x = c * (tile_w + gap)
        y = r * (tile_h + gap)
        base = base.draw_image(vt, x, y)

    # ensure bilevel and apply global invert if requested
    base = (base > 0).ifthenelse(255, 0)
    if invert:
        base = base ^ 255

    if thumbnail:
        base_thumbnail = base.thumbnail_image(thumbnail)
        base_thumbnail.write_to_file(out_path)
    else:
        base.write_to_file(
            out_path,
            compression=1, effort=1, filter="none",
            interlace=False, strip=True, bitdepth=1,
        )
\end{verbatim}
\end{tcolorbox}

Behaviour summary:

\begin{itemize}
  \item Tiles are NumPy arrays (0/255) and can be of slightly different sizes;
        they are centre-padded to a common square size.
  \item Optional per-tile titles are rendered via \verb|add_footer_label|
        before any global inversion.
  \item Tiles are placed in a row-major grid with a configurable gap.
  \item The final composite is made strictly bilevel, optionally inverted,
        and saved as either a full-resolution mosaic or a reduced
        \verb|thumbnail|.
\end{itemize}

\newpage
\section{JIT Warmup}

To avoid paying Numba compilation cost on the first “real” render, the
module provides a lightweight warmup function:

\begin{tcolorbox}[breakable, enhanced, colback=black!2, colframe=black!50]
\begin{verbatim}
def warmup_raster_kernels():
    try:
        dummy = np.zeros((8, 8), np.uint8)
        ys = np.arange(4, dtype=np.int32)
        xs = np.arange(4, dtype=np.int32)
        dy = np.array([-1, 0, 1], np.int32)
        dx = np.array([-1, 0, 1], np.int32)
        stamp_points(dummy, ys, xs, dy, dx)

        r = np.array([1, 2, 1, 3, 2], np.int32)
        bucket_by_radius(r, 1, 3)
        bucket_by_radius_parallel(r, 1, 3)
    except Exception as e:
        print(f"[jit] raster warmup skipped: {e}")
\end{verbatim}
\end{tcolorbox}

Calling \verb|warmup_raster_kernels()| once at startup ensures that:

\begin{itemize}
  \item \verb|stamp_points|,
  \item \verb|bucket_by_radius|,
  \item \verb|bucket_by_radius_parallel|
\end{itemize}

are all compiled and ready. Any issues during warmup are caught and logged
without interrupting the main programme.

\end{document}
